@using LrmCloud.Shared.DTOs.Translation
@using LrmCloud.Shared.DTOs.TranslationMemory
@using LrmCloud.Shared.DTOs.Glossary
@using LrmCloud.Web.Services
@inject TranslationService TranslationService
@inject TranslationMemoryService TmService
@inject GlossaryService GlossaryService
@inject LimitsService LimitsService
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime

<MudDialog>
    <TitleContent>
        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
            <MudIcon Icon="@Icons.Material.Filled.Translate" />
            <MudText Typo="Typo.h6">Translate Keys</MudText>
            @if (_currentStep == DialogStep.TmPreview)
            {
                <MudChip T="string" Size="Size.Small" Color="Color.Success">TM Preview</MudChip>
            }
        </MudStack>
    </TitleContent>

    <DialogContent>
        @if (_isLoadingProviders)
        {
            <MudStack AlignItems="AlignItems.Center" Class="py-8">
                <MudProgressCircular Indeterminate="true" />
                <MudText>Loading providers...</MudText>
            </MudStack>
        }
        else if (_currentStep == DialogStep.TmPreview)
        {
            @* TM Preview Step *@
            <MudStack Spacing="3">
                @if (_isCheckingTm)
                {
                    <MudStack AlignItems="AlignItems.Center" Class="py-4">
                        <MudProgressCircular Indeterminate="true" />
                        <MudText>Checking Translation Memory...</MudText>
                    </MudStack>
                }
                else
                {
                    <MudAlert Severity="Severity.Info" Dense="true">
                        Found <strong>@_tmMatches.Count</strong> TM matches.
                        Accept matches to use them (free), or skip to translate via provider.
                    </MudAlert>

                    @if (_tmMatches.Any())
                    {
                        <MudStack Row="true" Justify="Justify.SpaceBetween" Class="mb-2">
                            <MudButton Variant="Variant.Text"
                                       Color="Color.Success"
                                       Size="Size.Small"
                                       StartIcon="@Icons.Material.Filled.CheckCircle"
                                       OnClick="AcceptAllTmMatches">
                                Accept All (@_tmMatches.Count(m => m.Value.IsAccepted == null || m.Value.IsAccepted == true))
                            </MudButton>
                            <MudButton Variant="Variant.Text"
                                       Color="Color.Default"
                                       Size="Size.Small"
                                       StartIcon="@Icons.Material.Filled.Cancel"
                                       OnClick="RejectAllTmMatches">
                                Reject All
                            </MudButton>
                        </MudStack>

                        <MudPaper Outlined="true" Class="pa-0" Style="max-height: 400px; overflow-y: auto;">
                            <MudList T="string" Dense="true">
                                @foreach (var match in _tmMatches)
                                {
                                    var key = match.Key;
                                    var tmMatch = match.Value;
                                    var isAccepted = tmMatch.IsAccepted ?? true; // Default to accepted

                                    <MudListItem>
                                        <MudStack Spacing="1">
                                            <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                                                <MudStack Row="true" Spacing="1" AlignItems="AlignItems.Center">
                                                    <MudCheckBox T="bool"
                                                                 Value="@isAccepted"
                                                                 ValueChanged="@(v => ToggleTmMatch(key, v))"
                                                                 Color="Color.Success"
                                                                 Size="Size.Small" />
                                                    <MudText Typo="Typo.body2">
                                                        <strong>@tmMatch.KeyName</strong>
                                                        <MudText Typo="Typo.caption" Color="Color.Secondary" Class="ml-1">
                                                            â†’ @tmMatch.TargetLanguage.ToUpperInvariant()
                                                        </MudText>
                                                    </MudText>
                                                </MudStack>
                                                <MudChip T="string"
                                                         Size="Size.Small"
                                                         Color="@(tmMatch.Match.MatchPercent == 100 ? Color.Success : Color.Warning)">
                                                    @tmMatch.Match.MatchPercent%
                                                </MudChip>
                                            </MudStack>

                                            <MudStack Class="ml-8" Spacing="0">
                                                <MudText Typo="Typo.caption" Color="Color.Secondary">
                                                    Source: "@tmMatch.Match.SourceText"
                                                </MudText>
                                                <MudText Typo="Typo.caption" Color="@(isAccepted ? Color.Success : Color.Default)">
                                                    Translation: "@tmMatch.Match.TranslatedText"
                                                </MudText>
                                            </MudStack>
                                        </MudStack>
                                    </MudListItem>
                                    <MudDivider />
                                }
                            </MudList>
                        </MudPaper>
                    }

                    <MudStack Row="true" Justify="Justify.SpaceBetween" Class="mt-2">
                        <MudText Typo="Typo.body2">
                            <MudIcon Icon="@Icons.Material.Filled.Memory" Size="Size.Small" Color="Color.Success" Class="mr-1" />
                            <strong>@AcceptedTmCount</strong> from TM (free)
                        </MudText>
                        <MudText Typo="Typo.body2">
                            <MudIcon Icon="@Icons.Material.Filled.Translate" Size="Size.Small" Color="Color.Primary" Class="mr-1" />
                            <strong>@RemainingToTranslate</strong> via provider
                        </MudText>
                    </MudStack>
                }
            </MudStack>
        }
        else if (_isTranslating)
        {
            <MudStack AlignItems="AlignItems.Center" Spacing="4" Class="py-8">
                <MudProgressCircular Indeterminate="true" Size="Size.Large" />
                <MudText Typo="Typo.h6">Translating...</MudText>
                <MudText Color="Color.Secondary">
                    @RemainingToTranslate translations via @_selectedProvider
                </MudText>
                @if (_translationResult != null)
                {
                    <MudText Color="Color.Info">
                        @_translationResult.TranslatedCount translated, @_translationResult.FailedCount failed
                    </MudText>
                }
            </MudStack>
        }
        else if (_translationResult != null)
        {
            <TranslationResultSummary Result="_translationResult" OnClose="CloseResult" />
        }
        else
        {
            @* Configuration Step *@
            <MudStack Spacing="4">
                @if (!_providers.Any())
                {
                    <MudAlert Severity="Severity.Warning">
                        No translation providers configured. Please add an API key in Settings.
                    </MudAlert>
                }
                else
                {
                    @if (_usageWarning != null)
                    {
                        <MudAlert Severity="@(_usageBlocked ? Severity.Error : Severity.Warning)" Dense="true">
                            @_usageWarning
                            @if (_usageBlocked)
                            {
                                <MudLink Href="settings" Class="ml-2">Upgrade Plan</MudLink>
                            }
                        </MudAlert>
                    }

                    <MudText Typo="Typo.body2" Color="Color.Secondary">
                        Translate @(_keysToTranslate.Count > 0 ? $"{_keysToTranslate.Count} selected keys" : "all keys")
                        to the selected languages.
                    </MudText>

                    <MudSelect T="string"
                               @bind-Value="_selectedProvider"
                               Label="Translation Provider"
                               Variant="Variant.Outlined"
                               AnchorOrigin="Origin.BottomCenter">
                        @foreach (var provider in _providers.Where(p => p.IsConfigured))
                        {
                            <MudSelectItem Value="@provider.Name">
                                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                                    <MudIcon Icon="@GetProviderIcon(provider.Name)" Size="Size.Small" />
                                    <span>@provider.DisplayName</span>
                                    @if (!provider.RequiresApiKey)
                                    {
                                        <MudChip T="string" Size="Size.Small" Color="Color.Success">Free</MudChip>
                                    }
                                    @if (provider.ApiKeySource != null)
                                    {
                                        <MudText Typo="Typo.caption" Color="Color.Secondary">(@provider.ApiKeySource)</MudText>
                                    }
                                </MudStack>
                            </MudSelectItem>
                        }
                    </MudSelect>

                    <MudText Typo="Typo.subtitle2">Target Languages</MudText>
                    <MudStack Row="true" Wrap="Wrap.Wrap" Spacing="2">
                        @foreach (var lang in AvailableLanguages.Where(l => l != SourceLanguage))
                        {
                            var langCode = lang;
                            var isSelected = _selectedLanguages.Contains(langCode);
                            <MudChip T="string"
                                     Color="@(isSelected ? Color.Primary : Color.Default)"
                                     Variant="@(isSelected ? Variant.Filled : Variant.Outlined)"
                                     OnClick="@(() => ToggleLanguage(langCode))">
                                @langCode.ToUpperInvariant()
                            </MudChip>
                        }
                    </MudStack>

                    @if (!_selectedLanguages.Any())
                    {
                        <MudAlert Severity="Severity.Info" Dense="true">
                            Select at least one target language
                        </MudAlert>
                    }

                    <MudDivider />

                    <MudSwitch T="bool" @bind-Value="_onlyMissing" Color="Color.Primary">
                        Only translate missing translations
                    </MudSwitch>

                    <MudSwitch T="bool" @bind-Value="_overwrite" Color="Color.Warning" Disabled="@_onlyMissing">
                        Overwrite existing translations
                    </MudSwitch>

                    <MudTextField T="string"
                                  @bind-Value="_context"
                                  Label="Context (optional)"
                                  Placeholder="Provide context for better AI translations..."
                                  Variant="Variant.Outlined"
                                  Lines="2"
                                  HelperText="Context helps AI providers produce more accurate translations" />

                    <MudExpansionPanels Elevation="0" Class="mt-2">
                        <MudExpansionPanel Text="Translation Memory Options" Dense="true" IsInitiallyExpanded="false">
                            <MudStack Spacing="2">
                                <MudSwitch T="bool" @bind-Value="_useTm" Color="Color.Primary">
                                    <MudText Typo="Typo.body2">Use Translation Memory</MudText>
                                </MudSwitch>
                                <MudText Typo="Typo.caption" Color="Color.Secondary" Class="ml-10" Style="margin-top: -8px;">
                                    Check TM for existing translations before calling the provider
                                </MudText>

                                <MudSwitch T="bool" @bind-Value="_storeInTm" Color="Color.Primary">
                                    <MudText Typo="Typo.body2">Store translations in TM</MudText>
                                </MudSwitch>
                                <MudText Typo="Typo.caption" Color="Color.Secondary" Class="ml-10" Style="margin-top: -8px;">
                                    Save new translations to TM for future reuse
                                </MudText>

                                <MudSlider T="int" @bind-Value="_minMatchPercent"
                                           Min="70" Max="100" Step="5"
                                           Color="Color.Primary"
                                           Disabled="@(!_useTm)">
                                    <MudText Typo="Typo.body2">
                                        Minimum match: @_minMatchPercent%
                                        @if (_minMatchPercent == 100)
                                        {
                                            <span class="ml-1">(exact only)</span>
                                        }
                                        else
                                        {
                                            <span class="ml-1">(fuzzy)</span>
                                        }
                                    </MudText>
                                </MudSlider>
                                <MudText Typo="Typo.caption" Color="Color.Secondary" Class="ml-2" Style="margin-top: -8px;">
                                    Lower values allow fuzzy matches (similar but not exact)
                                </MudText>
                            </MudStack>
                        </MudExpansionPanel>
                    </MudExpansionPanels>

                    @* Glossary Preview *@
                    @if (_glossaryTerms.Any())
                    {
                        <MudAlert Severity="Severity.Info" Dense="true" Class="mt-2">
                            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                                <MudIcon Icon="@Icons.Material.Filled.Book" Size="Size.Small" />
                                <span><strong>@_glossaryTerms.Count</strong> glossary terms will be applied automatically</span>
                            </MudStack>
                            @if (_glossaryTerms.Count <= 5)
                            {
                                <MudStack Row="true" Wrap="Wrap.Wrap" Spacing="1" Class="mt-2">
                                    @foreach (var term in _glossaryTerms.Take(5))
                                    {
                                        <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">
                                            @term.SourceTerm
                                        </MudChip>
                                    }
                                </MudStack>
                            }
                        </MudAlert>
                    }
                }
            </MudStack>
        }
    </DialogContent>

    <DialogActions>
        @if (_translationResult != null)
        {
            <MudButton OnClick="CloseResult">Translate More</MudButton>
            <MudButton Color="Color.Primary" OnClick="@ApplyAndClose">
                Apply to Editor
            </MudButton>
        }
        else if (_currentStep == DialogStep.TmPreview)
        {
            <MudButton OnClick="BackToConfig">Back</MudButton>
            <MudButton Color="Color.Primary"
                       Variant="Variant.Filled"
                       OnClick="ProceedWithTranslation"
                       Disabled="@_isCheckingTm">
                @if (RemainingToTranslate > 0)
                {
                    <span>Translate @RemainingToTranslate Remaining</span>
                }
                else
                {
                    <span>Apply TM Matches</span>
                }
            </MudButton>
        }
        else
        {
            <MudButton OnClick="Cancel">Cancel</MudButton>
            @if (_useTm)
            {
                <MudButton Color="Color.Success"
                           Variant="Variant.Outlined"
                           Disabled="@(!CanTranslate)"
                           OnClick="CheckTmFirst"
                           StartIcon="@Icons.Material.Filled.Memory">
                    Check TM First
                </MudButton>
            }
            <MudButton Color="Color.Primary"
                       Variant="Variant.Filled"
                       Disabled="@(!CanTranslate)"
                       OnClick="StartTranslation">
                @if (_isTranslating)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                }
                Translate All
            </MudButton>
        }
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter]
    private IMudDialogInstance MudDialog { get; set; } = null!;

    [Parameter]
    public int ProjectId { get; set; }

    [Parameter]
    public string SourceLanguage { get; set; } = "en";

    [Parameter]
    public List<string> AvailableLanguages { get; set; } = new();

    [Parameter]
    public List<string> KeysToTranslate { get; set; } = new();

    /// <summary>
    /// Optional source texts for each key. When provided, these are used instead of database values.
    /// This allows translating unsaved edits from the UI.
    /// </summary>
    [Parameter]
    public Dictionary<string, string>? SourceTexts { get; set; }

    /// <summary>
    /// Optional metadata about keys being translated. When provided, overrides database values
    /// for key properties like IsPlural. This allows translating keys with unsaved UI changes.
    /// </summary>
    [Parameter]
    public Dictionary<string, KeyTranslationMetadata>? KeyMetadata { get; set; }

    private enum DialogStep { Config, TmPreview, Translating, Results }
    private DialogStep _currentStep = DialogStep.Config;

    private List<TranslationProviderDto> _providers = new();
    private string? _selectedProvider;
    private HashSet<string> _selectedLanguages = new();
    private List<string> _keysToTranslate = new();
    private bool _onlyMissing = true;
    private bool _overwrite = false;
    private string? _context;
    private bool _isLoadingProviders = true;
    private bool _isTranslating = false;
    private bool _isCheckingTm = false;
    private TranslateResponseDto? _translationResult;
    private string? _usageWarning;
    private bool _usageBlocked;

    // Translation Memory options
    private bool _useTm = true;
    private bool _storeInTm = true;
    private int _minMatchPercent = 100;

    // TM Preview data
    private Dictionary<string, TmPreviewMatch> _tmMatches = new();
    private List<TranslationResultDto> _acceptedTmResults = new();

    // Glossary data
    private List<GlossaryTermDto> _glossaryTerms = new();

    private const string ProviderStorageKey = "lrm_translate_provider";

    private bool CanTranslate => !_isLoadingProviders &&
                                  !_isTranslating &&
                                  !string.IsNullOrEmpty(_selectedProvider) &&
                                  _selectedLanguages.Any() &&
                                  !_usageBlocked;

    private int AcceptedTmCount => _tmMatches.Count(m => m.Value.IsAccepted ?? true);
    private int RemainingToTranslate => (_keysToTranslate.Count * _selectedLanguages.Count) - AcceptedTmCount;

    protected override async Task OnInitializedAsync()
    {
        _keysToTranslate = KeysToTranslate;

        // Pre-select all non-source languages
        _selectedLanguages = AvailableLanguages
            .Where(l => l != SourceLanguage)
            .ToHashSet();

        await Task.WhenAll(LoadProvidersAsync(), CheckUsageLimitsAsync(), LoadGlossaryAsync());
    }

    private async Task CheckUsageLimitsAsync()
    {
        var (isWarning, isBlocked, message) = await LimitsService.GetTranslationUsageWarningAsync();
        if (isWarning)
        {
            _usageWarning = message;
            _usageBlocked = isBlocked;
        }
    }

    private async Task LoadGlossaryAsync()
    {
        try
        {
            var response = await GlossaryService.GetProjectGlossaryAsync(ProjectId, includeInherited: true);
            if (response?.Terms != null)
            {
                // Filter to terms that match source language
                _glossaryTerms = response.Terms
                    .Where(t => t.SourceLanguage.Equals(SourceLanguage, StringComparison.OrdinalIgnoreCase))
                    .ToList();
            }
        }
        catch
        {
            // Glossary is optional - don't fail translation if we can't load it
        }
    }

    private async Task LoadProvidersAsync()
    {
        _isLoadingProviders = true;
        try
        {
            _providers = await TranslationService.GetProvidersAsync(ProjectId);

            // Try to restore previously selected provider from localStorage
            string? savedProvider = null;
            try
            {
                savedProvider = await JSRuntime.InvokeAsync<string?>("localStorage.getItem", ProviderStorageKey);
            }
            catch
            {
                // localStorage may not be available (SSR prerender)
            }

            // Use saved provider if it's still configured, otherwise fall back to first configured
            var configuredProviders = _providers.Where(p => p.IsConfigured).ToList();
            if (!string.IsNullOrEmpty(savedProvider) && configuredProviders.Any(p => p.Name == savedProvider))
            {
                _selectedProvider = savedProvider;
            }
            else
            {
                _selectedProvider = configuredProviders.FirstOrDefault()?.Name;
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load providers: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isLoadingProviders = false;
        }
    }

    private void ToggleLanguage(string lang)
    {
        if (_selectedLanguages.Contains(lang))
            _selectedLanguages.Remove(lang);
        else
            _selectedLanguages.Add(lang);
    }

    /// <summary>
    /// Step 1: Check TM for all keys/languages before translating
    /// </summary>
    private async Task CheckTmFirst()
    {
        _currentStep = DialogStep.TmPreview;
        _isCheckingTm = true;
        _tmMatches.Clear();

        try
        {
            // Check TM for each key and target language
            foreach (var keyName in _keysToTranslate)
            {
                // Get source text for this key
                string? sourceText = null;
                if (SourceTexts?.TryGetValue(keyName, out var provided) == true)
                {
                    sourceText = provided;
                }

                if (string.IsNullOrEmpty(sourceText))
                {
                    continue; // Skip keys without source text
                }

                foreach (var targetLang in _selectedLanguages)
                {
                    var request = new TmLookupRequest
                    {
                        SourceText = sourceText,
                        SourceLanguage = SourceLanguage,
                        TargetLanguage = targetLang,
                        MinMatchPercent = _minMatchPercent,
                        MaxResults = 1
                    };

                    var result = await TmService.LookupAsync(request);

                    if (result.IsSuccess && result.Data?.Matches.Any() == true)
                    {
                        var match = result.Data.Matches.First();
                        var matchKey = $"{keyName}:{targetLang}";
                        _tmMatches[matchKey] = new TmPreviewMatch
                        {
                            KeyName = keyName,
                            TargetLanguage = targetLang,
                            Match = match,
                            IsAccepted = true // Default to accepted
                        };
                    }
                }
            }

            if (_tmMatches.Any())
            {
                Snackbar.Add($"Found {_tmMatches.Count} TM matches", Severity.Success);
            }
            else
            {
                Snackbar.Add("No TM matches found", Severity.Info);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"TM check failed: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isCheckingTm = false;
        }
    }

    private void ToggleTmMatch(string key, bool accepted)
    {
        if (_tmMatches.TryGetValue(key, out var match))
        {
            match.IsAccepted = accepted;
        }
    }

    private void AcceptAllTmMatches()
    {
        foreach (var match in _tmMatches.Values)
        {
            match.IsAccepted = true;
        }
    }

    private void RejectAllTmMatches()
    {
        foreach (var match in _tmMatches.Values)
        {
            match.IsAccepted = false;
        }
    }

    private void BackToConfig()
    {
        _currentStep = DialogStep.Config;
        _tmMatches.Clear();
    }

    /// <summary>
    /// Step 2: Proceed with translation after TM preview
    /// </summary>
    private async Task ProceedWithTranslation()
    {
        // Build list of accepted TM results
        _acceptedTmResults.Clear();
        foreach (var (key, match) in _tmMatches.Where(m => m.Value.IsAccepted == true))
        {
            _acceptedTmResults.Add(new TranslationResultDto
            {
                Key = match.KeyName,
                TargetLanguage = match.TargetLanguage,
                SourceText = match.Match.SourceText,
                TranslatedText = match.Match.TranslatedText,
                Success = true,
                FromTm = true
            });

            // Increment TM use count (fire and forget)
            _ = TmService.IncrementUseCountAsync(match.Match.Id);
        }

        // Build list of keys/languages that still need translation
        var keysNeedingTranslation = new HashSet<string>();
        var languagesNeedingTranslation = new Dictionary<string, HashSet<string>>();

        foreach (var keyName in _keysToTranslate)
        {
            foreach (var targetLang in _selectedLanguages)
            {
                var matchKey = $"{keyName}:{targetLang}";
                var hasAcceptedTm = _tmMatches.TryGetValue(matchKey, out var match) && match.IsAccepted == true;

                if (!hasAcceptedTm)
                {
                    keysNeedingTranslation.Add(keyName);
                    if (!languagesNeedingTranslation.ContainsKey(keyName))
                    {
                        languagesNeedingTranslation[keyName] = new HashSet<string>();
                    }
                    languagesNeedingTranslation[keyName].Add(targetLang);
                }
            }
        }

        // If everything was covered by TM, just return the TM results
        if (!keysNeedingTranslation.Any())
        {
            _translationResult = new TranslateResponseDto
            {
                Success = true,
                TranslatedCount = _acceptedTmResults.Count,
                TmCount = _acceptedTmResults.Count,
                Results = _acceptedTmResults,
                Provider = "Translation Memory"
            };
            _currentStep = DialogStep.Results;
            return;
        }

        // Translate remaining via provider
        _isTranslating = true;
        _currentStep = DialogStep.Translating;

        try
        {
            // Save selected provider to localStorage for next time
            if (!string.IsNullOrEmpty(_selectedProvider))
            {
                try
                {
                    await JSRuntime.InvokeVoidAsync("localStorage.setItem", ProviderStorageKey, _selectedProvider);
                }
                catch
                {
                    // Ignore localStorage errors
                }
            }

            var request = new TranslateRequestDto
            {
                Keys = keysNeedingTranslation.ToList(),
                TargetLanguages = _selectedLanguages.ToList(),
                SourceLanguage = SourceLanguage,
                Provider = _selectedProvider,
                OnlyMissing = _onlyMissing,
                Overwrite = _overwrite,
                Context = _context,
                SaveToDatabase = false,
                SourceTexts = SourceTexts,
                KeyMetadata = KeyMetadata,
                TranslationMemory = new TmOptions
                {
                    UseTm = false, // Don't check TM again - we already did
                    StoreInTm = _storeInTm,
                    MinMatchPercent = _minMatchPercent
                }
            };

            _translationResult = await TranslationService.TranslateKeysAsync(ProjectId, request);

            // Merge TM results with provider results
            _translationResult.Results.AddRange(_acceptedTmResults);
            _translationResult.TranslatedCount += _acceptedTmResults.Count;
            _translationResult.TmCount += _acceptedTmResults.Count;

            if (_translationResult.Success)
            {
                Snackbar.Add($"Translated {_translationResult.TranslatedCount} keys successfully", Severity.Success);
                LimitsService.InvalidateCache();
                await CheckUsageLimitsAsync();
            }
            else if (_translationResult.Errors.Any())
            {
                Snackbar.Add(_translationResult.Errors.First(), Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Translation failed: {ex.Message}", Severity.Error);
            _translationResult = new TranslateResponseDto
            {
                Success = _acceptedTmResults.Count > 0, // Partial success if we have TM results
                Errors = [ex.Message],
                Results = _acceptedTmResults, // Still include TM results
                TranslatedCount = _acceptedTmResults.Count,
                TmCount = _acceptedTmResults.Count
            };
        }
        finally
        {
            _isTranslating = false;
            _currentStep = DialogStep.Results;
        }
    }

    /// <summary>
    /// Direct translation without TM preview (original flow)
    /// </summary>
    private async Task StartTranslation()
    {
        _isTranslating = true;
        _translationResult = null;

        try
        {
            // Save selected provider to localStorage for next time
            if (!string.IsNullOrEmpty(_selectedProvider))
            {
                try
                {
                    await JSRuntime.InvokeVoidAsync("localStorage.setItem", ProviderStorageKey, _selectedProvider);
                }
                catch
                {
                    // Ignore localStorage errors
                }
            }

            var request = new TranslateRequestDto
            {
                Keys = _keysToTranslate,
                TargetLanguages = _selectedLanguages.ToList(),
                SourceLanguage = SourceLanguage,
                Provider = _selectedProvider,
                OnlyMissing = _onlyMissing,
                Overwrite = _overwrite,
                Context = _context,
                SaveToDatabase = false,  // Return translations for UI preview, don't save yet
                SourceTexts = SourceTexts,  // Pass current UI values if provided
                KeyMetadata = KeyMetadata,  // Pass key metadata (e.g., IsPlural) for unsaved UI changes
                TranslationMemory = new TmOptions
                {
                    UseTm = _useTm,
                    StoreInTm = _storeInTm,
                    MinMatchPercent = _minMatchPercent
                }
            };

            _translationResult = await TranslationService.TranslateKeysAsync(ProjectId, request);

            if (_translationResult.Success)
            {
                Snackbar.Add($"Translated {_translationResult.TranslatedCount} keys successfully", Severity.Success);
                // Refresh usage limits
                LimitsService.InvalidateCache();
                await CheckUsageLimitsAsync();
            }
            else if (_translationResult.Errors.Any())
            {
                Snackbar.Add(_translationResult.Errors.First(), Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Translation failed: {ex.Message}", Severity.Error);
            _translationResult = new TranslateResponseDto
            {
                Success = false,
                Errors = [ex.Message]
            };
        }
        finally
        {
            _isTranslating = false;
        }
    }

    private void CloseResult()
    {
        _translationResult = null;
        _currentStep = DialogStep.Config;
        _tmMatches.Clear();
        _acceptedTmResults.Clear();
    }

    private void ApplyAndClose()
    {
        // Return the translation result to the parent so it can update the UI
        MudDialog.Close(DialogResult.Ok(_translationResult));
    }

    private void Cancel()
    {
        MudDialog.Cancel();
    }

    private static string GetProviderIcon(string provider) => provider switch
    {
        "google" => Icons.Custom.Brands.Google,
        "deepl" => Icons.Material.Filled.Language,
        "openai" => Icons.Material.Filled.Psychology,
        "claude" => Icons.Material.Filled.AutoAwesome,
        "azuretranslator" or "azureopenai" => Icons.Custom.Brands.Microsoft,
        "lingva" => Icons.Material.Filled.Public,
        "mymemory" => Icons.Material.Filled.Memory,
        "ollama" => Icons.Material.Filled.Computer,
        "libretranslate" => Icons.Material.Filled.Code,
        _ => Icons.Material.Filled.Translate
    };

    /// <summary>
    /// Holds a TM match during the preview step
    /// </summary>
    private class TmPreviewMatch
    {
        public required string KeyName { get; set; }
        public required string TargetLanguage { get; set; }
        public required TmMatchDto Match { get; set; }
        public bool? IsAccepted { get; set; } = true;
    }
}
