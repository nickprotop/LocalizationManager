@page "/projects/{ProjectId:int}/editor"
@attribute [Authorize]
@inject ProjectService ProjectService
@inject ResourceService ResourceService
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IJSRuntime JS
@inject IDialogService DialogService
@inject SnapshotService SnapshotService
@implements IAsyncDisposable
@using LrmCloud.Web.Models
@using LrmCloud.Web.Components
@using LrmCloud.Web.Helpers
@using LrmCloud.Shared.DTOs.Resources
@using LrmCloud.Shared.DTOs.Translation
@using MudBlazor

<PageTitle>@(_project?.Name ?? "Editor") - LRM Cloud</PageTitle>

@if (_isLoading)
{
    <MudStack>
        <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="50px" />
        <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="calc(100vh - 250px)" />
    </MudStack>
}
else if (_project == null)
{
    <MudAlert Severity="Severity.Error">
        Project not found or you don't have access to it.
        <MudButton Variant="Variant.Text" Color="Color.Primary" Href="/app">Go to Dashboard</MudButton>
    </MudAlert>
}
else
{
    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-4">
        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
            <MudIconButton Icon="@Icons.Material.Filled.ArrowBack"
                           OnClick="@(() => Navigation.NavigateTo($"/app/projects/{ProjectId}"))"
                           Size="Size.Small" />
            <MudText Typo="Typo.h5">@_project.Name</MudText>
            <MudChip T="string" Size="Size.Small" Color="@UiHelpers.GetFormatColor(_project.Format)">@_project.Format</MudChip>
        </MudStack>

        <MudStack Row="true" Spacing="2">
            @if (_hasUnsavedChanges)
            {
                <MudChip T="string" Color="Color.Warning" Size="Size.Small">Unsaved changes</MudChip>
            }
            <MudButton Variant="Variant.Outlined"
                       Size="Size.Small"
                       StartIcon="@Icons.Material.Filled.Refresh"
                       OnClick="@RefreshData"
                       Disabled="_isRefreshing">
                @if (_isRefreshing)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                }
                Refresh
            </MudButton>
            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary"
                       Size="Size.Small"
                       StartIcon="@Icons.Material.Filled.Save"
                       OnClick="@OpenSaveDialog"
                       Disabled="@(!_hasUnsavedChanges || _isSaving)">
                @if (_isSaving)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                }
                Save
            </MudButton>
        </MudStack>
    </MudStack>

    @if (_stats != null)
    {
        <MudStack Row="true" Class="mb-4" Spacing="2">
            <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">
                @_stats.TotalKeys keys
            </MudChip>
            @foreach (var lang in _stats.Languages)
            {
                <MudTooltip Text="@($"{lang.Value.TranslatedCount}/{_stats.TotalKeys} translated")">
                    <MudChip T="string" Size="Size.Small"
                             Color="@UiHelpers.GetCompletionColor(lang.Value.CompletionPercentage)"
                             Variant="Variant.Outlined">
                        @lang.Key: @lang.Value.CompletionPercentage.ToString("F0")%
                    </MudChip>
                </MudTooltip>
            }
        </MudStack>
    }

    <TranslationGrid @ref="_translationGrid"
                     ServerDataFunc="@LoadServerData"
                     Languages="@_languages"
                     DefaultLanguage="@_project.DefaultLanguage"
                     OnRowSelected="@OnRowSelected"
                     OnAddKeyClicked="@OpenAddKeyDialog"
                     OnTranslateClicked="@OnTranslateSelected"
                     OnDeleteClicked="@OnDeleteSelected"
                     OnCellChanged="@OnCellChanged"
                     OnSearchTextChanged="@OnSearchTextChanged" />

    <MudDrawer @bind-Open="_drawerOpen"
               Anchor="Anchor.Right"
               Elevation="1"
               Variant="DrawerVariant.Temporary"
               Width="400px">
        <MudDrawerHeader>
            <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Style="width: 100%;">
                <MudText Typo="Typo.h6">Edit Key</MudText>
                <MudIconButton Icon="@Icons.Material.Filled.Close" OnClick="@CloseDrawer" Size="Size.Small" />
            </MudStack>
        </MudDrawerHeader>
        <MudDrawerContainer Class="pa-4">
            @if (_selectedRow != null)
            {
                <KeyDetailDrawer @ref="_keyDetailDrawer"
                                 Row="@_selectedRow"
                                 Languages="@_languages"
                                 DefaultLanguage="@_project.DefaultLanguage"
                                 ProjectFormat="@_project.Format"
                                 SupportsPluralKeys="@SupportsPluralKeys"
                                 OnSave="@SaveKeyDetails"
                                 OnTranslate="@TranslateKey"
                                 OnDelete="@DeleteKey"
                                 OnTypeChanged="@OnKeyTypeChanged" />
            }
        </MudDrawerContainer>
    </MudDrawer>
}

<AddKeyDialog @ref="_addKeyDialog" OnKeyAdded="@OnKeyAdded" ProjectId="@ProjectId" />
<ConfirmDeleteDialog @ref="_deleteDialog" OnConfirmed="@OnDeleteConfirmed" />

@* Save Changes Dialog *@
<MudDialog @bind-Visible="_saveDialogVisible" Options="@(new DialogOptions { MaxWidth = MaxWidth.Small, FullWidth = true })">
    <TitleContent>
        <MudText Typo="Typo.h6">
            <MudIcon Icon="@Icons.Material.Filled.Save" Class="mr-2" />
            Save Changes
        </MudText>
    </TitleContent>
    <DialogContent>
        <MudText Typo="Typo.body2" Class="mb-3">
            @_pendingSaveCount translation(s) will be saved.
        </MudText>
        <MudTextField @bind-Value="_saveMessage"
                      Label="Message (optional)"
                      Placeholder="e.g., Updated French translations"
                      HelperText="This message will be saved with the snapshot for history tracking"
                      Lines="2" />
        <MudCheckBox @bind-Value="_createSnapshotOnSave"
                     Label="Create snapshot after saving"
                     Class="mt-3" />
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="CloseSaveDialog">Cancel</MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SaveChangesWithMessage" Disabled="_isSaving">
            @if (_isSaving)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
            }
            Save Changes
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    [Parameter]
    public int ProjectId { get; set; }

    private ProjectDto? _project;
    private ProjectStatsDto? _stats;
    private List<string> _languages = new();
    private bool _isLoading = true;
    private bool _isRefreshing;
    private bool _isSaving;
    private bool _hasUnsavedChanges;
    private bool _drawerOpen;
    private TranslationGridRow? _selectedRow;        // Clone for drawer editing (isolated)
    private TranslationGridRow? _originalSelectedRow; // Original row reference (in grid)
    private KeyDetailDrawer? _keyDetailDrawer;
    private AddKeyDialog? _addKeyDialog;
    private ConfirmDeleteDialog? _deleteDialog;
    private IEnumerable<TranslationGridRow>? _pendingDeleteRows;
    private TranslationGrid? _translationGrid;
    private string _searchText = string.Empty;
    private Dictionary<string, TranslationGridRow> _editedRows = new();

    // Save dialog
    private bool _saveDialogVisible;
    private string _saveMessage = "";
    private bool _createSnapshotOnSave = true;
    private int _pendingSaveCount;

    /// <summary>
    /// Whether the current project format supports plural keys.
    /// JSON/i18next support plurals, RESX does not.
    /// </summary>
    private bool SupportsPluralKeys => _project?.Format?.ToLowerInvariant() switch
    {
        "json" => true,
        "i18next" => true,
        "resx" => false,
        _ => false
    };

    protected override async Task OnInitializedAsync()
    {
        await LoadDataAsync();
    }

    private async Task LoadDataAsync()
    {
        _isLoading = true;
        try
        {
            _project = await ProjectService.GetProjectAsync(ProjectId);
            if (_project != null)
            {
                _stats = await ResourceService.GetProjectStatsAsync(ProjectId);
                _languages = _stats?.Languages.Keys.ToList() ?? new List<string> { _project.DefaultLanguage };

                // Ensure default language is first
                if (_languages.Contains(_project.DefaultLanguage))
                {
                    _languages.Remove(_project.DefaultLanguage);
                    _languages.Insert(0, _project.DefaultLanguage);
                }
                // Grid will load data via ServerData callback
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading project: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isLoading = false;
        }
    }

    /// <summary>
    /// Server-side data loading callback for the grid.
    /// </summary>
    private async Task<GridData<TranslationGridRow>> LoadServerData(GridState<TranslationGridRow> state)
    {
        try
        {
            // Get sort info
            var sortDef = state.SortDefinitions.FirstOrDefault();
            var sortBy = sortDef?.SortBy;
            var sortDesc = sortDef?.Descending ?? false;

            // Call paginated API
            var result = await ResourceService.GetResourceKeysPagedAsync(
                ProjectId,
                state.Page + 1,  // MudDataGrid uses 0-indexed pages
                state.PageSize,
                _searchText,
                sortBy,
                sortDesc);

            // Map API results to grid rows
            var rows = new List<TranslationGridRow>();
            foreach (var detail in result.Items)
            {
                // Check if we have a cached edited row
                if (_editedRows.TryGetValue(detail.KeyName, out var editedRow))
                {
                    rows.Add(editedRow);
                    continue;
                }

                var row = new TranslationGridRow
                {
                    KeyId = detail.Id,
                    KeyName = detail.KeyName,
                    KeyPath = detail.KeyPath,
                    IsPlural = detail.IsPlural,
                    Comment = detail.Comment,
                    Version = detail.Version,
                    UpdatedAt = detail.UpdatedAt
                };

                foreach (var translation in detail.Translations)
                {
                    // Use key that includes plural form for plural keys
                    var key = detail.IsPlural
                        ? TranslationGridRow.GetKey(translation.LanguageCode, translation.PluralForm)
                        : translation.LanguageCode;

                    row.Translations[key] = new TranslationCell
                    {
                        TranslationId = translation.Id,
                        LanguageCode = translation.LanguageCode,
                        Value = translation.Value,
                        OriginalValue = translation.Value,
                        PluralForm = translation.PluralForm,
                        Status = translation.Status,
                        Version = translation.Version
                    };
                }

                // Ensure all languages have entries
                foreach (var lang in _languages)
                {
                    if (detail.IsPlural)
                    {
                        // For plural keys, ensure all plural forms exist
                        foreach (var pluralForm in PluralForms.Common)
                        {
                            var key = TranslationGridRow.GetKey(lang, pluralForm);
                            if (!row.Translations.ContainsKey(key))
                            {
                                row.Translations[key] = new TranslationCell
                                {
                                    LanguageCode = lang,
                                    PluralForm = pluralForm,
                                    Value = null,
                                    OriginalValue = null
                                };
                            }
                        }
                    }
                    else
                    {
                        // For non-plural keys, ensure language exists
                        if (!row.Translations.ContainsKey(lang))
                        {
                            row.Translations[lang] = new TranslationCell
                            {
                                LanguageCode = lang,
                                Value = null,
                                OriginalValue = null
                            };
                        }
                    }
                }

                rows.Add(row);
            }

            return new GridData<TranslationGridRow>
            {
                Items = rows,
                TotalItems = result.TotalCount
            };
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading data: {ex.Message}", Severity.Error);
            return new GridData<TranslationGridRow> { Items = new List<TranslationGridRow>(), TotalItems = 0 };
        }
    }

    private void OnSearchTextChanged(string search)
    {
        _searchText = search;
    }

    private async Task RefreshData()
    {
        if (_hasUnsavedChanges)
        {
            Snackbar.Add("Please save or discard your changes before refreshing", Severity.Warning);
            return;
        }

        _isRefreshing = true;
        try
        {
            _stats = await ResourceService.GetProjectStatsAsync(ProjectId);
            _editedRows.Clear();
            if (_translationGrid != null)
            {
                await _translationGrid.ReloadAsync();
            }
            Snackbar.Add("Data refreshed", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error refreshing: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isRefreshing = false;
        }
    }

    // ============================================================
    // Save Dialog Methods
    // ============================================================

    private void OpenSaveDialog()
    {
        // Count pending changes
        _pendingSaveCount = _editedRows.Values
            .SelectMany(r => r.Translations.Values)
            .Count(t => t.IsDirty);

        // Generate default message
        var languagesChanged = _editedRows.Values
            .SelectMany(r => r.Translations.Where(t => t.Value.IsDirty))
            .Select(t => t.Key)
            .Distinct()
            .ToList();

        if (languagesChanged.Count == 1)
        {
            _saveMessage = $"Updated {_pendingSaveCount} translations in {languagesChanged[0]}";
        }
        else if (languagesChanged.Count > 1)
        {
            _saveMessage = $"Updated {_pendingSaveCount} translations in {languagesChanged.Count} languages";
        }
        else
        {
            _saveMessage = "Updated via web editor";
        }

        _saveDialogVisible = true;
    }

    private void CloseSaveDialog()
    {
        _saveDialogVisible = false;
        _saveMessage = "";
    }

    private async Task SaveChangesWithMessage()
    {
        _saveDialogVisible = false;
        await SaveChanges(_createSnapshotOnSave ? _saveMessage : null);
    }

    private async Task SaveChanges(string? snapshotMessage = null)
    {
        _isSaving = true;
        var savedCount = 0;
        var errorCount = 0;

        try
        {
            foreach (var row in _editedRows.Values)
            {
                foreach (var (langCode, cell) in row.Translations.Where(t => t.Value.IsDirty))
                {
                    var request = new UpdateTranslationRequest
                    {
                        Value = cell.Value ?? "",
                        PluralForm = cell.PluralForm,
                        Status = "translated"
                    };

                    var result = await ResourceService.UpdateTranslationAsync(
                        ProjectId, row.KeyName, langCode, request);

                    if (result.IsSuccess)
                    {
                        cell.IsDirty = false;
                        cell.OriginalValue = cell.Value;
                        savedCount++;
                    }
                    else
                    {
                        errorCount++;
                    }
                }
            }

            // Remove rows that have no more dirty changes
            var keysToRemove = _editedRows
                .Where(kv => !kv.Value.Translations.Values.Any(t => t.IsDirty))
                .Select(kv => kv.Key)
                .ToList();
            foreach (var key in keysToRemove)
            {
                _editedRows.Remove(key);
            }

            _hasUnsavedChanges = _editedRows.Any(kv => kv.Value.Translations.Values.Any(t => t.IsDirty));

            if (errorCount > 0)
                Snackbar.Add($"Saved {savedCount} translations, {errorCount} failed", Severity.Warning);
            else if (savedCount > 0)
                Snackbar.Add($"Saved {savedCount} translations", Severity.Success);

            // Create snapshot if message was provided and save was successful
            if (!string.IsNullOrWhiteSpace(snapshotMessage) && savedCount > 0 && errorCount == 0)
            {
                try
                {
                    var snapshotResult = await SnapshotService.CreateSnapshotAsync(ProjectId, snapshotMessage);
                    if (snapshotResult.IsSuccess)
                    {
                        Snackbar.Add($"Snapshot {snapshotResult.Data?.SnapshotId} created", Severity.Info);
                    }
                }
                catch (Exception snapshotEx)
                {
                    // Log but don't fail the save operation
                    Snackbar.Add($"Changes saved but snapshot creation failed: {snapshotEx.Message}", Severity.Warning);
                }
            }

            // Refresh stats
            _stats = await ResourceService.GetProjectStatsAsync(ProjectId);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSaving = false;
        }
    }

    private void OnRowSelected(TranslationGridRow row)
    {
        _originalSelectedRow = row;
        _selectedRow = row.Clone(); // Drawer works on a clone to isolate changes
        _drawerOpen = true;
    }

    private void CloseDrawer()
    {
        _drawerOpen = false;
        _selectedRow = null;
        _originalSelectedRow = null;
    }

    private void OnCellChanged((TranslationGridRow Row, string LanguageCode, string Value) args)
    {
        // Track the edited row
        if (!_editedRows.ContainsKey(args.Row.KeyName))
        {
            _editedRows[args.Row.KeyName] = args.Row;
        }
        _hasUnsavedChanges = true;
    }

    private void OpenAddKeyDialog()
    {
        _addKeyDialog?.Open();
    }

    private async Task OnKeyAdded(ResourceKeyDto key)
    {
        await RefreshData();
    }

    private async Task OnTranslateSelected(IEnumerable<TranslationGridRow> rows)
    {
        if (_project == null) return;

        var rowList = rows.ToList();

        // Build source texts from current UI state (may include unsaved edits)
        var sourceTexts = BuildSourceTextsFromRows(rowList, _project.DefaultLanguage);

        var parameters = new DialogParameters
        {
            { nameof(TranslateDialog.ProjectId), ProjectId },
            { nameof(TranslateDialog.SourceLanguage), _project.DefaultLanguage },
            { nameof(TranslateDialog.AvailableLanguages), _languages },
            { nameof(TranslateDialog.KeysToTranslate), rowList.Select(r => r.KeyName).ToList() },
            { nameof(TranslateDialog.SourceTexts), sourceTexts }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Medium,
            FullWidth = true,
            CloseButton = true,
            BackdropClick = false
        };

        var dialog = await DialogService.ShowAsync<TranslateDialog>("Translate", parameters, options);
        var result = await dialog.Result;

        if (result is { Canceled: false, Data: TranslateResponseDto translationResult })
        {
            // Apply translations to UI state instead of refreshing from DB
            ApplyTranslationsToUI(rowList, translationResult);
        }
    }

    /// <summary>
    /// Applies translation results to the UI state, marking cells as dirty so Save button enables.
    /// Handles both non-plural and plural keys.
    /// </summary>
    private void ApplyTranslationsToUI(List<TranslationGridRow> rows, TranslateResponseDto translationResult)
    {
        var rowsByKey = rows.ToDictionary(r => r.KeyName);
        var appliedCount = 0;

        foreach (var translationRes in translationResult.Results.Where(r => r.Success))
        {
            if (!rowsByKey.TryGetValue(translationRes.Key, out var row))
            {
                continue;
            }

            // Build the cell key: "lang" for non-plural, "lang:pluralForm" for plural
            var cellKey = string.IsNullOrEmpty(translationRes.PluralForm)
                ? translationRes.TargetLanguage
                : TranslationGridRow.GetKey(translationRes.TargetLanguage, translationRes.PluralForm);

            if (!row.Translations.TryGetValue(cellKey, out var cell))
            {
                // Create new cell for this language/plural form
                cell = new TranslationCell
                {
                    LanguageCode = translationRes.TargetLanguage,
                    PluralForm = translationRes.PluralForm,
                    Value = null,
                    OriginalValue = null
                };
                row.Translations[cellKey] = cell;
            }

            // Apply translated text and mark as dirty
            cell.Value = translationRes.TranslatedText;
            cell.IsDirty = true;

            // Track edited row
            if (!_editedRows.ContainsKey(row.KeyName))
            {
                _editedRows[row.KeyName] = row;
            }

            appliedCount++;
        }

        if (appliedCount > 0)
        {
            _hasUnsavedChanges = true;
            Snackbar.Add($"Applied {appliedCount} translations. Click Save to persist changes.", Severity.Info);
            StateHasChanged();
        }
    }

    private void OnDeleteSelected(IEnumerable<TranslationGridRow> rows)
    {
        _pendingDeleteRows = rows;
        _deleteDialog?.Open(
            "Delete Keys",
            $"Are you sure you want to delete {rows.Count()} key(s)? This action cannot be undone.",
            rows.Select(r => r.KeyName).ToList());
    }

    private async Task OnDeleteConfirmed()
    {
        if (_pendingDeleteRows == null) return;

        var deleted = 0;
        var failed = 0;

        foreach (var row in _pendingDeleteRows)
        {
            var result = await ResourceService.DeleteResourceKeyAsync(ProjectId, row.KeyName);
            if (result.IsSuccess)
                deleted++;
            else
                failed++;
        }

        if (failed > 0)
            Snackbar.Add($"Deleted {deleted} keys, {failed} failed", Severity.Warning);
        else
            Snackbar.Add($"Deleted {deleted} keys", Severity.Success);

        _pendingDeleteRows = null;
        await RefreshData();
    }

    private void SaveKeyDetails(TranslationGridRow row)
    {
        // Stage changes in the editor (don't save to DB yet)
        // User must click the main Save button to persist with optional snapshot

        // Apply changes from the drawer's clone to the original row in the grid
        if (_originalSelectedRow != null)
        {
            _originalSelectedRow.ApplyFrom(row);

            // Track the original row (not the clone) in edited rows
            if (!_editedRows.ContainsKey(_originalSelectedRow.KeyName))
            {
                _editedRows[_originalSelectedRow.KeyName] = _originalSelectedRow;
            }
        }

        // Mark that we have unsaved changes
        _hasUnsavedChanges = true;

        // Close the drawer
        _drawerOpen = false;
        _selectedRow = null;
        _originalSelectedRow = null;

        Snackbar.Add("Changes staged. Click Save to persist.", Severity.Info);
    }

    private async Task TranslateKey(TranslationGridRow row)
    {
        if (_project == null) return;

        // Build source texts from current UI state (may include unsaved edits)
        var sourceTexts = BuildSourceTextsFromRows(new List<TranslationGridRow> { row }, _project.DefaultLanguage);

        var parameters = new DialogParameters
        {
            { nameof(TranslateDialog.ProjectId), ProjectId },
            { nameof(TranslateDialog.SourceLanguage), _project.DefaultLanguage },
            { nameof(TranslateDialog.AvailableLanguages), _languages },
            { nameof(TranslateDialog.KeysToTranslate), new List<string> { row.KeyName } },
            { nameof(TranslateDialog.SourceTexts), sourceTexts }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Medium,
            FullWidth = true,
            CloseButton = true,
            BackdropClick = false
        };

        var dialog = await DialogService.ShowAsync<TranslateDialog>("Translate", parameters, options);
        var result = await dialog.Result;

        if (result is { Canceled: false, Data: TranslateResponseDto translationResult })
        {
            // Apply translations to the drawer row only (cells will update in place)
            // User must click "Apply" to stage changes, then "Save" to persist
            ApplyTranslationsToDrawerRow(row, translationResult);
        }
    }

    /// <summary>
    /// Applies translation results to the currently selected drawer row.
    /// Unlike ApplyTranslationsToUI, this does NOT stage to _editedRows - the user must click Apply.
    /// Handles both non-plural and plural keys.
    /// </summary>
    private void ApplyTranslationsToDrawerRow(TranslationGridRow row, TranslateResponseDto translationResult)
    {
        var appliedCount = 0;

        foreach (var translationRes in translationResult.Results.Where(r => r.Success && r.Key == row.KeyName))
        {
            // Build the cell key: "lang" for non-plural, "lang:pluralForm" for plural
            var cellKey = string.IsNullOrEmpty(translationRes.PluralForm)
                ? translationRes.TargetLanguage
                : TranslationGridRow.GetKey(translationRes.TargetLanguage, translationRes.PluralForm);

            if (!row.Translations.TryGetValue(cellKey, out var cell))
            {
                // Create new cell for this language/plural form
                cell = new TranslationCell
                {
                    LanguageCode = translationRes.TargetLanguage,
                    PluralForm = translationRes.PluralForm,
                    Value = null,
                    OriginalValue = null
                };
                row.Translations[cellKey] = cell;
            }

            // Apply translated text and mark as dirty
            cell.Value = translationRes.TranslatedText;
            cell.IsDirty = true;
            appliedCount++;
        }

        if (appliedCount > 0)
        {
            // Refresh the drawer's plural form display to show new cells
            _keyDetailDrawer?.RefreshActivePluralForms();
            Snackbar.Add($"Applied {appliedCount} translations. Click Apply to stage changes.", Severity.Success);
            StateHasChanged();
        }
    }

    /// <summary>
    /// Builds a dictionary of source texts from the current UI state.
    /// This allows translating unsaved edits (what the user sees in the editor).
    /// For plural keys, includes all plural forms with "keyName:pluralForm" keys.
    /// </summary>
    private Dictionary<string, string> BuildSourceTextsFromRows(List<TranslationGridRow> rows, string defaultLanguage)
    {
        var sourceTexts = new Dictionary<string, string>();

        foreach (var row in rows)
        {
            if (row.IsPlural)
            {
                // For plural keys, include all plural forms
                foreach (var pluralForm in PluralForms.All)
                {
                    var cell = row.GetCell(defaultLanguage, pluralForm);
                    if (cell != null && !string.IsNullOrEmpty(cell.Value))
                    {
                        // Use "keyName:pluralForm" format for plural keys
                        sourceTexts[$"{row.KeyName}:{pluralForm}"] = cell.Value;
                    }
                }
            }
            else
            {
                // For non-plural keys, just use the key name
                var cell = row.Translations.GetValueOrDefault(defaultLanguage);
                if (cell != null && !string.IsNullOrEmpty(cell.Value))
                {
                    sourceTexts[row.KeyName] = cell.Value;
                }
            }
        }

        return sourceTexts;
    }

    private async Task DeleteKey(TranslationGridRow row)
    {
        _pendingDeleteRows = new[] { row };
        _deleteDialog?.Open(
            "Delete Key",
            $"Are you sure you want to delete '{row.KeyName}'? This action cannot be undone.",
            new List<string> { row.KeyName });
    }

    private void OnKeyTypeChanged((TranslationGridRow Row, bool IsPlural) args)
    {
        // Type change is on the clone - just update UI to show changes in the drawer.
        // The actual change will be applied when the user clicks "Apply" via SaveKeyDetails.
        // Don't track or mark as dirty here - that happens in SaveKeyDetails.
        StateHasChanged();
    }

    // ============================================================
    // Keyboard Shortcuts
    // ============================================================

    private DotNetObjectReference<Editor>? _dotNetRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("lrmKeyboard.init", _dotNetRef);
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_dotNetRef != null)
        {
            await JS.InvokeVoidAsync("lrmKeyboard.dispose");
            _dotNetRef.Dispose();
        }
    }

    [JSInvokable]
    public async Task OnKeyboardSave()
    {
        if (_hasUnsavedChanges && !_isSaving)
        {
            await SaveChanges();
            StateHasChanged();
        }
    }

    [JSInvokable]
    public async Task OnKeyboardSearch()
    {
        // Focus the search input in the grid
        await JS.InvokeVoidAsync("lrmKeyboard.focusElement", ".translation-grid input[type='text']");
    }

    [JSInvokable]
    public void OnKeyboardEscape()
    {
        if (_drawerOpen)
        {
            CloseDrawer();
            StateHasChanged();
        }
    }

    [JSInvokable]
    public void OnKeyboardDelete()
    {
        // This would require getting selected items from the grid
        // For now, just show a message
        Snackbar.Add("Select rows and click Delete to remove keys", Severity.Info);
    }
}
