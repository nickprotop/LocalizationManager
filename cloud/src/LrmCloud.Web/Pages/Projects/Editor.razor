@page "/projects/{ProjectId:int}/editor"
@attribute [Authorize]
@inject ProjectService ProjectService
@inject ResourceService ResourceService
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IJSRuntime JS
@inject IDialogService DialogService
@inject ReviewWorkflowService WorkflowService
@implements IAsyncDisposable
@using LrmCloud.Web.Models
@using LrmCloud.Web.Components
@using LrmCloud.Web.Helpers
@using LrmCloud.Shared.DTOs.Resources
@using LrmCloud.Shared.DTOs.Translation
@using LrmCloud.Shared.DTOs.Reviews
@using MudBlazor

<PageTitle>@(_project?.Name ?? "Editor") - LRM Cloud</PageTitle>

@if (_isLoading)
{
    <MudStack>
        <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="50px" />
        <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="calc(100vh - 250px)" />
    </MudStack>
}
else if (_project == null)
{
    <MudAlert Severity="Severity.Error">
        Project not found or you don't have access to it.
        <MudButton Variant="Variant.Text" Color="Color.Primary" Href="">Go to Dashboard</MudButton>
    </MudAlert>
}
else
{
    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-4">
        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
            <MudIconButton Icon="@Icons.Material.Filled.ArrowBack"
                           OnClick="@(() => Navigation.NavigateTo($"projects/{ProjectId}"))"
                           Size="Size.Small" />
            <MudText Typo="Typo.h5">@_project.Name</MudText>
            <MudChip T="string" Size="Size.Small" Color="@UiHelpers.GetFormatColor(_project.Format)">@_project.Format</MudChip>
        </MudStack>

        <MudStack Row="true" Spacing="2">
            @if (_hasUnsavedChanges)
            {
                <MudChip T="string" Color="Color.Warning" Size="Size.Small">Unsaved changes</MudChip>
            }
            <MudButton Variant="Variant.Outlined"
                       Size="Size.Small"
                       StartIcon="@Icons.Material.Filled.Refresh"
                       OnClick="@RefreshData"
                       Disabled="_isRefreshing">
                @if (_isRefreshing)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                }
                Refresh
            </MudButton>
            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary"
                       Size="Size.Small"
                       StartIcon="@Icons.Material.Filled.Save"
                       OnClick="@OpenSaveDialog"
                       Disabled="@(!_hasUnsavedChanges || _isSaving)">
                @if (_isSaving)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                }
                Save
            </MudButton>
        </MudStack>
    </MudStack>

    @if (_stats != null)
    {
        <MudStack Row="true" Class="mb-4" Spacing="2">
            <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">
                @_stats.TotalKeys keys
            </MudChip>
            @foreach (var lang in _stats.Languages)
            {
                <MudTooltip Text="@($"{lang.Value.TranslatedCount}/{_stats.TotalKeys} translated")">
                    <MudChip T="string" Size="Size.Small"
                             Color="@UiHelpers.GetCompletionColor(lang.Value.CompletionPercentage)"
                             Variant="Variant.Outlined">
                        @lang.Key: @lang.Value.CompletionPercentage.ToString("F0")%
                    </MudChip>
                </MudTooltip>
            }
        </MudStack>
    }

    <TranslationGrid @ref="_translationGrid"
                     ServerDataFunc="@LoadServerData"
                     Languages="@_languages"
                     DefaultLanguage="@_project.DefaultLanguage"
                     OnRowSelected="@OnRowSelected"
                     OnAddKeyClicked="@OpenAddKeyDialog"
                     OnTranslateClicked="@OnTranslateSelected"
                     OnDeleteClicked="@OnDeleteSelected"
                     OnCellChanged="@OnCellChanged"
                     OnSearchTextChanged="@OnSearchTextChanged"
                     WorkflowEnabled="@_workflowEnabled"
                     CanReview="@_canReview"
                     CanApprove="@_canApprove"
                     OnReviewClicked="@OnReviewSelected"
                     OnApproveClicked="@OnApproveSelected" />

    <MudDrawer @bind-Open="_drawerOpen"
               Anchor="Anchor.Right"
               Elevation="1"
               Variant="DrawerVariant.Temporary"
               Width="400px">
        <MudDrawerHeader>
            <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Style="width: 100%;">
                <MudText Typo="Typo.h6">Key Preview</MudText>
                <MudIconButton Icon="@Icons.Material.Filled.Close" OnClick="@CloseDrawer" Size="Size.Small" />
            </MudStack>
        </MudDrawerHeader>
        <MudDrawerContainer Class="pa-4">
            @if (_selectedRow != null)
            {
                <KeyDetailDrawer Row="@_selectedRow"
                                 Languages="@_languages"
                                 DefaultLanguage="@_project.DefaultLanguage"
                                 OnEdit="@OpenKeyEditorDialog"
                                 OnTranslate="@TranslateKey"
                                 OnDelete="@DeleteKey" />
            }
        </MudDrawerContainer>
    </MudDrawer>
}

<AddKeyDialog @ref="_addKeyDialog" OnKeyAdded="@OnKeyAdded" ProjectId="@ProjectId" />
<ConfirmDeleteDialog @ref="_deleteDialog" OnConfirmed="@OnDeleteConfirmed" />

@* Save Changes Dialog *@
<MudDialog @bind-Visible="_saveDialogVisible" Options="@(new DialogOptions { MaxWidth = MaxWidth.Small, FullWidth = true })">
    <TitleContent>
        <MudText Typo="Typo.h6">
            <MudIcon Icon="@Icons.Material.Filled.Save" Class="mr-2" />
            Save Changes
        </MudText>
    </TitleContent>
    <DialogContent>
        <MudText Typo="Typo.body2" Class="mb-3">
            @_pendingSaveCount translation(s) will be saved.
        </MudText>
        <MudTextField @bind-Value="_saveMessage"
                      Label="Message (optional)"
                      Placeholder="e.g., Updated French translations"
                      HelperText="This message will be recorded in sync history"
                      Lines="2" />
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="CloseSaveDialog">Cancel</MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SaveChangesWithMessage" Disabled="_isSaving">
            @if (_isSaving)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
            }
            Save Changes
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    [Parameter]
    public int ProjectId { get; set; }

    private ProjectDto? _project;
    private ProjectStatsDto? _stats;
    private List<string> _languages = new();
    private bool _isLoading = true;
    private bool _isRefreshing;
    private bool _isSaving;
    private bool _hasUnsavedChanges;
    private bool _drawerOpen;
    private TranslationGridRow? _selectedRow;        // Row shown in drawer (for preview and passing to dialog)
    private AddKeyDialog? _addKeyDialog;
    private ConfirmDeleteDialog? _deleteDialog;
    private IEnumerable<TranslationGridRow>? _pendingDeleteRows;
    private TranslationGrid? _translationGrid;
    private string _searchText = string.Empty;
    private Dictionary<string, TranslationGridRow> _editedRows = new();

    // Save dialog
    private bool _saveDialogVisible;
    private string _saveMessage = "";
    private int _pendingSaveCount;

    // Workflow
    private bool _workflowEnabled;
    private bool _canReview;
    private bool _canApprove;

    /// <summary>
    /// Whether the current project format supports plural keys.
    /// JSON/i18next support plurals, RESX does not.
    /// </summary>
    private bool SupportsPluralKeys => _project?.Format?.ToLowerInvariant() switch
    {
        "json" => true,
        "i18next" => true,
        "resx" => false,
        _ => false
    };

    protected override async Task OnInitializedAsync()
    {
        await LoadDataAsync();
    }

    private async Task LoadDataAsync()
    {
        _isLoading = true;
        try
        {
            _project = await ProjectService.GetProjectAsync(ProjectId);
            if (_project != null)
            {
                _stats = await ResourceService.GetProjectStatsAsync(ProjectId);
                _languages = _stats?.Languages.Keys.ToList() ?? new List<string> { _project.DefaultLanguage };

                // Ensure default language is first
                if (_languages.Contains(_project.DefaultLanguage))
                {
                    _languages.Remove(_project.DefaultLanguage);
                    _languages.Insert(0, _project.DefaultLanguage);
                }

                // Load workflow settings
                await LoadWorkflowAsync();

                // Grid will load data via ServerData callback
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading project: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isLoading = false;
        }
    }

    private async Task LoadWorkflowAsync()
    {
        try
        {
            var settings = await WorkflowService.GetWorkflowSettingsAsync(ProjectId);
            if (settings != null)
            {
                _workflowEnabled = settings.ReviewWorkflowEnabled;

                if (_workflowEnabled)
                {
                    // Check user permissions
                    _canReview = await WorkflowService.CanReviewAsync(ProjectId);
                    _canApprove = await WorkflowService.CanApproveAsync(ProjectId);
                }
            }
        }
        catch
        {
            // Workflow feature may not be enabled, ignore errors
            _workflowEnabled = false;
        }
    }

    /// <summary>
    /// Server-side data loading callback for the grid.
    /// </summary>
    private async Task<GridData<TranslationGridRow>> LoadServerData(GridState<TranslationGridRow> state)
    {
        try
        {
            // Get sort info
            var sortDef = state.SortDefinitions.FirstOrDefault();
            var sortBy = sortDef?.SortBy;
            var sortDesc = sortDef?.Descending ?? false;

            // Call paginated API
            var result = await ResourceService.GetResourceKeysPagedAsync(
                ProjectId,
                state.Page + 1,  // MudDataGrid uses 0-indexed pages
                state.PageSize,
                _searchText,
                sortBy,
                sortDesc);

            // Map API results to grid rows
            var rows = new List<TranslationGridRow>();
            foreach (var detail in result.Items)
            {
                // Check if we have a cached edited row
                if (_editedRows.TryGetValue(detail.KeyName, out var editedRow))
                {
                    rows.Add(editedRow);
                    continue;
                }

                var row = new TranslationGridRow
                {
                    KeyId = detail.Id,
                    KeyName = detail.KeyName,
                    KeyPath = detail.KeyPath,
                    IsPlural = detail.IsPlural,
                    Comment = detail.Comment,
                    Version = detail.Version,
                    UpdatedAt = detail.UpdatedAt,
                    // Set original values for dirty tracking
                    OriginalComment = detail.Comment,
                    OriginalIsPlural = detail.IsPlural
                };

                foreach (var translation in detail.Translations)
                {
                    // Use key that includes plural form for plural keys
                    var key = detail.IsPlural
                        ? TranslationGridRow.GetKey(translation.LanguageCode, translation.PluralForm)
                        : translation.LanguageCode;

                    row.Translations[key] = new TranslationCell
                    {
                        TranslationId = translation.Id,
                        LanguageCode = translation.LanguageCode,
                        Value = translation.Value,
                        OriginalValue = translation.Value,
                        PluralForm = translation.PluralForm,
                        Status = translation.Status,
                        Version = translation.Version
                    };
                }

                // Ensure all languages have entries
                foreach (var lang in _languages)
                {
                    if (detail.IsPlural)
                    {
                        // For plural keys, ensure all plural forms exist
                        foreach (var pluralForm in PluralForms.Common)
                        {
                            var key = TranslationGridRow.GetKey(lang, pluralForm);
                            if (!row.Translations.ContainsKey(key))
                            {
                                row.Translations[key] = new TranslationCell
                                {
                                    LanguageCode = lang,
                                    PluralForm = pluralForm,
                                    Value = null,
                                    OriginalValue = null
                                };
                            }
                        }
                    }
                    else
                    {
                        // For non-plural keys, ensure language exists
                        if (!row.Translations.ContainsKey(lang))
                        {
                            row.Translations[lang] = new TranslationCell
                            {
                                LanguageCode = lang,
                                Value = null,
                                OriginalValue = null
                            };
                        }
                    }
                }

                rows.Add(row);
            }

            return new GridData<TranslationGridRow>
            {
                Items = rows,
                TotalItems = result.TotalCount
            };
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading data: {ex.Message}", Severity.Error);
            return new GridData<TranslationGridRow> { Items = new List<TranslationGridRow>(), TotalItems = 0 };
        }
    }

    private void OnSearchTextChanged(string search)
    {
        _searchText = search;
    }

    private async Task RefreshData()
    {
        if (_hasUnsavedChanges)
        {
            Snackbar.Add("Please save or discard your changes before refreshing", Severity.Warning);
            return;
        }

        _isRefreshing = true;
        try
        {
            _stats = await ResourceService.GetProjectStatsAsync(ProjectId);
            _editedRows.Clear();
            if (_translationGrid != null)
            {
                await _translationGrid.ReloadAsync();
            }
            Snackbar.Add("Data refreshed", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error refreshing: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isRefreshing = false;
        }
    }

    // ============================================================
    // Save Dialog Methods
    // ============================================================

    private void OpenSaveDialog()
    {
        // Count pending changes
        _pendingSaveCount = _editedRows.Values
            .SelectMany(r => r.Translations.Values)
            .Count(t => t.IsDirty);

        // Generate default message
        var languagesChanged = _editedRows.Values
            .SelectMany(r => r.Translations.Where(t => t.Value.IsDirty))
            .Select(t => t.Key)
            .Distinct()
            .ToList();

        if (languagesChanged.Count == 1)
        {
            _saveMessage = $"Updated {_pendingSaveCount} translations in {languagesChanged[0]}";
        }
        else if (languagesChanged.Count > 1)
        {
            _saveMessage = $"Updated {_pendingSaveCount} translations in {languagesChanged.Count} languages";
        }
        else
        {
            _saveMessage = "Updated via web editor";
        }

        _saveDialogVisible = true;
    }

    private void CloseSaveDialog()
    {
        _saveDialogVisible = false;
        _saveMessage = "";
    }

    private async Task SaveChangesWithMessage()
    {
        _saveDialogVisible = false;
        await SaveChanges();
    }

    private async Task SaveChanges()
    {
        _isSaving = true;

        try
        {
            // Build the batch save request
            var request = new BatchSaveRequest
            {
                Message = _saveMessage
            };

            foreach (var row in _editedRows.Values)
            {
                // Add key metadata changes (Comment only - IsPlural changes are more complex)
                if (row.IsKeyMetadataDirty && row.Comment != row.OriginalComment)
                {
                    request.KeyChanges.Add(new KeyChangeDto
                    {
                        KeyName = row.KeyName,
                        Comment = row.Comment
                    });
                }

                // Add translation changes
                foreach (var (langKey, cell) in row.Translations.Where(t => t.Value.IsDirty))
                {
                    request.TranslationChanges.Add(new TranslationChangeDto
                    {
                        KeyName = row.KeyName,
                        LanguageCode = cell.LanguageCode,
                        Value = cell.Value ?? "",
                        PluralForm = cell.PluralForm,
                        Status = "translated"
                    });
                }
            }

            // Call batch save API
            var result = await ResourceService.BatchSaveAsync(ProjectId, request);

            if (result.IsSuccess && result.Data != null)
            {
                var response = result.Data;

                // Mark all dirty cells as clean
                foreach (var row in _editedRows.Values)
                {
                    if (row.Comment != row.OriginalComment)
                    {
                        row.OriginalComment = row.Comment;
                    }

                    foreach (var cell in row.Translations.Values.Where(t => t.IsDirty))
                    {
                        cell.IsDirty = false;
                        cell.OriginalValue = cell.Value;
                    }
                }

                // Remove rows that have no more dirty changes
                var keysToRemove = _editedRows
                    .Where(kv => !kv.Value.Translations.Values.Any(t => t.IsDirty) && !kv.Value.IsKeyMetadataDirty)
                    .Select(kv => kv.Key)
                    .ToList();
                foreach (var key in keysToRemove)
                {
                    _editedRows.Remove(key);
                }

                _hasUnsavedChanges = _editedRows.Any(kv =>
                    kv.Value.Translations.Values.Any(t => t.IsDirty) || kv.Value.IsKeyMetadataDirty);

                // Show success message with history ID
                var message = $"Saved {response.TranslationsModified} translations";
                if (response.KeysModified > 0)
                {
                    message += $", {response.KeysModified} keys updated";
                }
                if (!string.IsNullOrEmpty(response.HistoryId))
                {
                    message += $" (history: {response.HistoryId})";
                }
                Snackbar.Add(message, Severity.Success);

                // Refresh stats
                _stats = await ResourceService.GetProjectStatsAsync(ProjectId);
            }
            else
            {
                Snackbar.Add($"Error saving: {result.ErrorMessage}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSaving = false;
        }
    }

    private void OnRowSelected(TranslationGridRow row)
    {
        _selectedRow = row; // Drawer is now read-only preview
        _drawerOpen = true;
    }

    private void CloseDrawer()
    {
        _drawerOpen = false;
        _selectedRow = null;
    }

    private void OnCellChanged((TranslationGridRow Row, string LanguageCode, string Value) args)
    {
        // Track the edited row
        if (!_editedRows.ContainsKey(args.Row.KeyName))
        {
            _editedRows[args.Row.KeyName] = args.Row;
        }
        _hasUnsavedChanges = true;
    }

    private void OpenAddKeyDialog()
    {
        _addKeyDialog?.Open();
    }

    private async Task OnKeyAdded(ResourceKeyDto key)
    {
        await RefreshData();
    }

    private async Task OnTranslateSelected(IEnumerable<TranslationGridRow> rows)
    {
        if (_project == null) return;

        var rowList = rows.ToList();

        // Build source texts from current UI state (may include unsaved edits)
        var sourceTexts = BuildSourceTextsFromRows(rowList, _project.DefaultLanguage);

        // Build key metadata to tell API about unsaved state (e.g., IsPlural)
        var keyMetadata = BuildKeyMetadataFromRows(rowList);

        var parameters = new DialogParameters
        {
            { nameof(TranslateDialog.ProjectId), ProjectId },
            { nameof(TranslateDialog.SourceLanguage), _project.DefaultLanguage },
            { nameof(TranslateDialog.AvailableLanguages), _languages },
            { nameof(TranslateDialog.KeysToTranslate), rowList.Select(r => r.KeyName).ToList() },
            { nameof(TranslateDialog.SourceTexts), sourceTexts },
            { nameof(TranslateDialog.KeyMetadata), keyMetadata }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Medium,
            FullWidth = true,
            CloseButton = true,
            BackdropClick = false
        };

        var dialog = await DialogService.ShowAsync<TranslateDialog>("Translate", parameters, options);
        var result = await dialog.Result;

        if (result is { Canceled: false, Data: TranslateResponseDto translationResult })
        {
            // Apply translations to UI state instead of refreshing from DB
            ApplyTranslationsToUI(rowList, translationResult);
        }
    }

    /// <summary>
    /// Applies translation results to the UI state, marking cells as dirty so Save button enables.
    /// Handles both non-plural and plural keys.
    /// </summary>
    private void ApplyTranslationsToUI(List<TranslationGridRow> rows, TranslateResponseDto translationResult)
    {
        var rowsByKey = rows.ToDictionary(r => r.KeyName);
        var appliedCount = 0;

        foreach (var translationRes in translationResult.Results.Where(r => r.Success))
        {
            if (!rowsByKey.TryGetValue(translationRes.Key, out var row))
            {
                continue;
            }

            // Build the cell key: "lang" for non-plural, "lang:pluralForm" for plural
            var cellKey = string.IsNullOrEmpty(translationRes.PluralForm)
                ? translationRes.TargetLanguage
                : TranslationGridRow.GetKey(translationRes.TargetLanguage, translationRes.PluralForm);

            if (!row.Translations.TryGetValue(cellKey, out var cell))
            {
                // Create new cell for this language/plural form
                cell = new TranslationCell
                {
                    LanguageCode = translationRes.TargetLanguage,
                    PluralForm = translationRes.PluralForm,
                    Value = null,
                    OriginalValue = null
                };
                row.Translations[cellKey] = cell;
            }

            // Apply translated text and mark as dirty
            cell.Value = translationRes.TranslatedText;
            cell.IsDirty = true;

            // Track edited row
            if (!_editedRows.ContainsKey(row.KeyName))
            {
                _editedRows[row.KeyName] = row;
            }

            appliedCount++;
        }

        if (appliedCount > 0)
        {
            _hasUnsavedChanges = true;
            Snackbar.Add($"Applied {appliedCount} translations. Click Save to persist changes.", Severity.Info);
            StateHasChanged();
        }
    }

    private void OnDeleteSelected(IEnumerable<TranslationGridRow> rows)
    {
        _pendingDeleteRows = rows;
        _deleteDialog?.Open(
            "Delete Keys",
            $"Are you sure you want to delete {rows.Count()} key(s)? This action cannot be undone.",
            rows.Select(r => r.KeyName).ToList());
    }

    private async Task OnDeleteConfirmed()
    {
        if (_pendingDeleteRows == null) return;

        var deleted = 0;
        var failed = 0;

        foreach (var row in _pendingDeleteRows)
        {
            var result = await ResourceService.DeleteResourceKeyAsync(ProjectId, row.KeyName);
            if (result.IsSuccess)
                deleted++;
            else
                failed++;
        }

        if (failed > 0)
            Snackbar.Add($"Deleted {deleted} keys, {failed} failed", Severity.Warning);
        else
            Snackbar.Add($"Deleted {deleted} keys", Severity.Success);

        _pendingDeleteRows = null;
        await RefreshData();
    }

    /// <summary>
    /// Opens the KeyEditorDialog for full editing capabilities.
    /// Called from the drawer's Edit button.
    /// </summary>
    private async Task OpenKeyEditorDialog(TranslationGridRow row)
    {
        if (_project == null) return;

        // Create a clone for the dialog to work on (isolated from grid)
        var editingRow = row.Clone();

        var parameters = new DialogParameters
        {
            { nameof(KeyEditorDialog.Row), editingRow },
            { nameof(KeyEditorDialog.Languages), _languages },
            { nameof(KeyEditorDialog.DefaultLanguage), _project.DefaultLanguage },
            { nameof(KeyEditorDialog.ProjectFormat), _project.Format },
            { nameof(KeyEditorDialog.SupportsPluralKeys), SupportsPluralKeys },
            { nameof(KeyEditorDialog.OnTranslate), EventCallback.Factory.Create<TranslationGridRow>(this, TranslateKeyInDialog) }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Large,
            FullWidth = true,
            CloseButton = true,
            BackdropClick = false
        };

        var dialog = await DialogService.ShowAsync<KeyEditorDialog>("Edit Key", parameters, options);
        var result = await dialog.Result;

        if (result is { Canceled: false, Data: TranslationGridRow editedRow })
        {
            // Apply changes from the dialog's clone to the original row in the grid
            row.ApplyFrom(editedRow);

            // Track the row as edited
            if (!_editedRows.ContainsKey(row.KeyName))
            {
                _editedRows[row.KeyName] = row;
            }

            // Mark that we have unsaved changes
            _hasUnsavedChanges = true;

            // Close the drawer since edits have been applied
            _drawerOpen = false;
            _selectedRow = null;

            Snackbar.Add("Changes staged. Click Save to persist.", Severity.Info);
            StateHasChanged();
        }
    }

    /// <summary>
    /// Handles translation requests from within the KeyEditorDialog.
    /// Opens the translate dialog and applies results to the dialog's row.
    /// </summary>
    private async Task TranslateKeyInDialog(TranslationGridRow dialogRow)
    {
        if (_project == null) return;

        var rowList = new List<TranslationGridRow> { dialogRow };

        // Build source texts from the dialog row's current state
        var sourceTexts = BuildSourceTextsFromRows(rowList, _project.DefaultLanguage);

        // Build key metadata
        var keyMetadata = BuildKeyMetadataFromRows(rowList);

        var parameters = new DialogParameters
        {
            { nameof(TranslateDialog.ProjectId), ProjectId },
            { nameof(TranslateDialog.SourceLanguage), _project.DefaultLanguage },
            { nameof(TranslateDialog.AvailableLanguages), _languages },
            { nameof(TranslateDialog.KeysToTranslate), new List<string> { dialogRow.KeyName } },
            { nameof(TranslateDialog.SourceTexts), sourceTexts },
            { nameof(TranslateDialog.KeyMetadata), keyMetadata }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Medium,
            FullWidth = true,
            CloseButton = true,
            BackdropClick = false
        };

        var dialog = await DialogService.ShowAsync<TranslateDialog>("Translate", parameters, options);
        var result = await dialog.Result;

        if (result is { Canceled: false, Data: TranslateResponseDto translationResult })
        {
            // Apply translations directly to the dialog row (it's a clone, user will save from dialog)
            ApplyTranslationsToRow(dialogRow, translationResult);
        }
    }

    /// <summary>
    /// Applies translation results to a specific row.
    /// </summary>
    private void ApplyTranslationsToRow(TranslationGridRow row, TranslateResponseDto translationResult)
    {
        var appliedCount = 0;

        foreach (var translationRes in translationResult.Results.Where(r => r.Success && r.Key == row.KeyName))
        {
            var cellKey = string.IsNullOrEmpty(translationRes.PluralForm)
                ? translationRes.TargetLanguage
                : TranslationGridRow.GetKey(translationRes.TargetLanguage, translationRes.PluralForm);

            if (!row.Translations.TryGetValue(cellKey, out var cell))
            {
                cell = new TranslationCell
                {
                    LanguageCode = translationRes.TargetLanguage,
                    PluralForm = translationRes.PluralForm,
                    Value = null,
                    OriginalValue = null
                };
                row.Translations[cellKey] = cell;
            }

            cell.Value = translationRes.TranslatedText;
            cell.IsDirty = true;
            appliedCount++;
        }

        if (appliedCount > 0)
        {
            Snackbar.Add($"Applied {appliedCount} translation(s)", Severity.Success);
        }
    }

    /// <summary>
    /// Translates a single key from the drawer's Translate button.
    /// Since the drawer now shows the actual row (not a clone), translations are
    /// directly applied and marked as staged for saving.
    /// </summary>
    private async Task TranslateKey(TranslationGridRow row)
    {
        if (_project == null) return;

        var rowList = new List<TranslationGridRow> { row };

        // Build source texts from current UI state (may include unsaved edits)
        var sourceTexts = BuildSourceTextsFromRows(rowList, _project.DefaultLanguage);

        // Build key metadata to tell API about unsaved state (e.g., IsPlural)
        var keyMetadata = BuildKeyMetadataFromRows(rowList);

        var parameters = new DialogParameters
        {
            { nameof(TranslateDialog.ProjectId), ProjectId },
            { nameof(TranslateDialog.SourceLanguage), _project.DefaultLanguage },
            { nameof(TranslateDialog.AvailableLanguages), _languages },
            { nameof(TranslateDialog.KeysToTranslate), new List<string> { row.KeyName } },
            { nameof(TranslateDialog.SourceTexts), sourceTexts },
            { nameof(TranslateDialog.KeyMetadata), keyMetadata }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Medium,
            FullWidth = true,
            CloseButton = true,
            BackdropClick = false
        };

        var dialog = await DialogService.ShowAsync<TranslateDialog>("Translate", parameters, options);
        var result = await dialog.Result;

        if (result is { Canceled: false, Data: TranslateResponseDto translationResult })
        {
            // Apply translations directly to the row and stage them
            ApplyTranslationsToUI(rowList, translationResult);
        }
    }

    /// <summary>
    /// Builds a dictionary of source texts from the current UI state.
    /// This allows translating unsaved edits (what the user sees in the editor).
    /// For plural keys, includes all plural forms with "keyName:pluralForm" keys.
    /// </summary>
    private Dictionary<string, string> BuildSourceTextsFromRows(List<TranslationGridRow> rows, string defaultLanguage)
    {
        var sourceTexts = new Dictionary<string, string>();

        foreach (var row in rows)
        {
            if (row.IsPlural)
            {
                // For plural keys, include all plural forms
                foreach (var pluralForm in PluralForms.All)
                {
                    var cell = row.GetCell(defaultLanguage, pluralForm);
                    if (cell != null && !string.IsNullOrEmpty(cell.Value))
                    {
                        // Use "keyName:pluralForm" format for plural keys
                        sourceTexts[$"{row.KeyName}:{pluralForm}"] = cell.Value;
                    }
                }
            }
            else
            {
                // For non-plural keys, just use the key name
                var cell = row.Translations.GetValueOrDefault(defaultLanguage);
                if (cell != null && !string.IsNullOrEmpty(cell.Value))
                {
                    sourceTexts[row.KeyName] = cell.Value;
                }
            }
        }

        return sourceTexts;
    }

    /// <summary>
    /// Builds a dictionary of key metadata from the current UI state.
    /// This tells the API about unsaved changes like IsPlural conversions.
    /// </summary>
    private Dictionary<string, KeyTranslationMetadata> BuildKeyMetadataFromRows(List<TranslationGridRow> rows)
    {
        var metadata = new Dictionary<string, KeyTranslationMetadata>();

        foreach (var row in rows)
        {
            metadata[row.KeyName] = new KeyTranslationMetadata
            {
                IsPlural = row.IsPlural
            };
        }

        return metadata;
    }

    private async Task DeleteKey(TranslationGridRow row)
    {
        _pendingDeleteRows = new[] { row };
        _deleteDialog?.Open(
            "Delete Key",
            $"Are you sure you want to delete '{row.KeyName}'? This action cannot be undone.",
            new List<string> { row.KeyName });
    }

    // ============================================================
    // Review/Approve Actions
    // ============================================================

    private async Task OnReviewSelected(IEnumerable<TranslationGridRow> rows)
    {
        if (_project == null || !_workflowEnabled || !_canReview) return;

        var translationIds = rows
            .SelectMany(r => r.Translations.Values)
            .Where(t => t.TranslationId.HasValue && t.Status == "translated")
            .Select(t => t.TranslationId!.Value)
            .ToList();

        if (!translationIds.Any())
        {
            Snackbar.Add("No translations eligible for review (must be in 'translated' status)", Severity.Warning);
            return;
        }

        try
        {
            var request = new ReviewTranslationsRequest
            {
                TranslationIds = translationIds
            };

            var result = await WorkflowService.ReviewTranslationsAsync(ProjectId, request);
            if (result != null)
            {
                Snackbar.Add($"Reviewed {result.ProcessedCount} translation(s){(result.SkippedCount > 0 ? $", {result.SkippedCount} skipped" : "")}", Severity.Success);

                // Refresh grid to show new status
                if (_translationGrid != null)
                {
                    await _translationGrid.ReloadAsync();
                }
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error reviewing translations: {ex.Message}", Severity.Error);
        }
    }

    private async Task OnApproveSelected(IEnumerable<TranslationGridRow> rows)
    {
        if (_project == null || !_workflowEnabled || !_canApprove) return;

        var translationIds = rows
            .SelectMany(r => r.Translations.Values)
            .Where(t => t.TranslationId.HasValue && (t.Status == "reviewed" || t.Status == "translated"))
            .Select(t => t.TranslationId!.Value)
            .ToList();

        if (!translationIds.Any())
        {
            Snackbar.Add("No translations eligible for approval (must be in 'translated' or 'reviewed' status)", Severity.Warning);
            return;
        }

        try
        {
            var request = new ApproveTranslationsRequest
            {
                TranslationIds = translationIds
            };

            var result = await WorkflowService.ApproveTranslationsAsync(ProjectId, request);
            if (result != null)
            {
                Snackbar.Add($"Approved {result.ProcessedCount} translation(s){(result.SkippedCount > 0 ? $", {result.SkippedCount} skipped" : "")}", Severity.Success);

                // Refresh grid to show new status
                if (_translationGrid != null)
                {
                    await _translationGrid.ReloadAsync();
                }
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error approving translations: {ex.Message}", Severity.Error);
        }
    }

    // ============================================================
    // Keyboard Shortcuts
    // ============================================================

    private DotNetObjectReference<Editor>? _dotNetRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("lrmKeyboard.init", _dotNetRef);
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_dotNetRef != null)
        {
            await JS.InvokeVoidAsync("lrmKeyboard.dispose");
            _dotNetRef.Dispose();
        }
    }

    [JSInvokable]
    public async Task OnKeyboardSave()
    {
        if (_hasUnsavedChanges && !_isSaving)
        {
            await SaveChanges();
            StateHasChanged();
        }
    }

    [JSInvokable]
    public async Task OnKeyboardSearch()
    {
        // Focus the search input in the grid
        await JS.InvokeVoidAsync("lrmKeyboard.focusElement", ".translation-grid input[type='text']");
    }

    [JSInvokable]
    public void OnKeyboardEscape()
    {
        if (_drawerOpen)
        {
            CloseDrawer();
            StateHasChanged();
        }
    }

    [JSInvokable]
    public void OnKeyboardDelete()
    {
        // This would require getting selected items from the grid
        // For now, just show a message
        Snackbar.Add("Select rows and click Delete to remove keys", Severity.Info);
    }
}
