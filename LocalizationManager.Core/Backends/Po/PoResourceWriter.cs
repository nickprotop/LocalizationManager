// Copyright (c) 2025 Nikolaos Protopapas
// Licensed under the MIT License

using System.Globalization;
using System.Text;
using LocalizationManager.Core.Abstractions;
using LocalizationManager.Core.Configuration;
using LocalizationManager.Core.Models;

namespace LocalizationManager.Core.Backends.Po;

/// <summary>
/// Writes ResourceFile objects to GNU gettext PO format files.
/// Supports plurals, context, comments, and proper line wrapping.
/// </summary>
public class PoResourceWriter : IResourceWriter
{
    private readonly PoFormatConfiguration _config;
    private const int MaxLineLength = 77; // PO convention

    public PoResourceWriter(PoFormatConfiguration? config = null)
    {
        _config = config ?? new PoFormatConfiguration();
    }

    /// <inheritdoc />
    public async Task WriteAsync(ResourceFile file, CancellationToken ct = default)
    {
        if (string.IsNullOrEmpty(file.Language.FilePath))
            throw new ArgumentException("FilePath is required for file-based writing", nameof(file));

        var content = SerializeToString(file);

        // Ensure directory exists
        var directory = Path.GetDirectoryName(file.Language.FilePath);
        if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
            Directory.CreateDirectory(directory);

        // Atomic write: write to temp file then rename
        var tempPath = file.Language.FilePath + ".tmp";
        await File.WriteAllTextAsync(tempPath, content, Encoding.UTF8, ct);
        File.Move(tempPath, file.Language.FilePath, overwrite: true);
    }

    /// <inheritdoc />
    public void Write(ResourceFile file)
    {
        WriteAsync(file).GetAwaiter().GetResult();
    }

    /// <inheritdoc />
    public async Task CreateLanguageFileAsync(
        string baseName,
        string cultureCode,
        string targetPath,
        ResourceFile? sourceFile = null,
        bool copyEntries = true,
        CancellationToken ct = default)
    {
        var filePath = GetFilePathForLanguage(baseName, cultureCode, targetPath);

        var entries = new List<ResourceEntry>();
        if (copyEntries && sourceFile != null)
        {
            // Copy entries with empty values
            entries = sourceFile.Entries.Select(e => new ResourceEntry
            {
                Key = e.Key,
                Value = "",
                Comment = e.Comment,
                IsPlural = e.IsPlural,
                PluralForms = e.IsPlural
                    ? e.PluralForms?.ToDictionary(kv => kv.Key, kv => "")
                    : null
            }).ToList();
        }

        var languageInfo = new LanguageInfo
        {
            Code = cultureCode,
            Name = GetLanguageDisplayName(cultureCode),
            BaseName = baseName,
            FilePath = filePath,
            IsDefault = false
        };

        var file = new ResourceFile
        {
            Language = languageInfo,
            Entries = entries
        };

        await WriteAsync(file, ct);
    }

    /// <inheritdoc />
    public Task DeleteLanguageFileAsync(LanguageInfo language, CancellationToken ct = default)
    {
        if (!string.IsNullOrEmpty(language.FilePath) && File.Exists(language.FilePath))
        {
            File.Delete(language.FilePath);
        }
        return Task.CompletedTask;
    }

    /// <inheritdoc />
    public string SerializeToString(ResourceFile file)
    {
        var sb = new StringBuilder();

        // Write header
        WriteHeader(sb, file);

        // Write entries
        foreach (var entry in file.Entries)
        {
            WriteEntry(sb, entry, file.Language.Code);
        }

        return sb.ToString();
    }

    private void WriteHeader(StringBuilder sb, ResourceFile file)
    {
        // PO header is an entry with empty msgid
        sb.AppendLine("# PO file generated by LRM");
        sb.AppendLine("#");
        sb.AppendLine("msgid \"\"");
        sb.AppendLine("msgstr \"\"");

        var headerLines = new List<string>
        {
            $"Project-Id-Version: {_config.Domain}\\n",
            $"POT-Creation-Date: {DateTime.UtcNow:yyyy-MM-dd HH:mm}+0000\\n",
            $"PO-Revision-Date: {DateTime.UtcNow:yyyy-MM-dd HH:mm}+0000\\n",
            "Last-Translator: \\n",
            "Language-Team: \\n",
            $"Language: {file.Language.Code}\\n",
            "MIME-Version: 1.0\\n",
            "Content-Type: text/plain; charset=UTF-8\\n",
            "Content-Transfer-Encoding: 8bit\\n",
            $"Plural-Forms: {GetPluralFormsHeader(file.Language.Code)}\\n",
            "X-Generator: LRM (Localization Resource Manager)\\n"
        };

        foreach (var line in headerLines)
        {
            sb.AppendLine($"\"{line}\"");
        }

        sb.AppendLine();
    }

    private void WriteEntry(StringBuilder sb, ResourceEntry entry, string languageCode)
    {
        // Write comment if present
        if (!string.IsNullOrEmpty(entry.Comment))
        {
            foreach (var line in entry.Comment.Split('\n'))
            {
                sb.AppendLine($"# {line}");
            }
        }

        // Determine if we have context (key contains |)
        string? context = null;
        var msgId = entry.Key;

        var pipeIndex = entry.Key.IndexOf('|');
        if (pipeIndex > 0)
        {
            context = entry.Key.Substring(0, pipeIndex);
            msgId = entry.Key.Substring(pipeIndex + 1);
        }

        // Write context if present
        if (!string.IsNullOrEmpty(context))
        {
            WritePoString(sb, "msgctxt", context);
        }

        // Write msgid
        WritePoString(sb, "msgid", msgId);

        // Handle plurals
        if (entry.IsPlural && entry.PluralForms != null)
        {
            // Write msgid_plural - prefer SourcePluralText (preserved from original PO file)
            // Fall back to "other" form or first available form for non-PO sources
            var pluralSource = entry.SourcePluralText
                ?? entry.PluralForms.GetValueOrDefault("other")
                ?? entry.PluralForms.Values.FirstOrDefault()
                ?? entry.Value
                ?? "";
            WritePoString(sb, "msgid_plural", pluralSource);

            // Write msgstr[n] for each plural form
            var categories = PoPluralMapper.GetCategoriesForLanguage(languageCode);
            for (int i = 0; i < categories.Length; i++)
            {
                var category = categories[i];
                var value = entry.PluralForms.GetValueOrDefault(category) ?? "";
                WritePoString(sb, $"msgstr[{i}]", value);
            }
        }
        else
        {
            // Write msgstr
            WritePoString(sb, "msgstr", entry.Value ?? "");
        }

        sb.AppendLine();
    }

    private void WritePoString(StringBuilder sb, string keyword, string value)
    {
        var escaped = EscapeString(value);
        var prefix = $"{keyword} ";

        // If the line is short enough, write it directly
        if (prefix.Length + escaped.Length + 2 <= MaxLineLength)
        {
            sb.AppendLine($"{prefix}\"{escaped}\"");
            return;
        }

        // Multi-line format
        sb.AppendLine($"{keyword} \"\"");
        WriteWrappedString(sb, escaped);
    }

    private void WriteWrappedString(StringBuilder sb, string escaped)
    {
        // Wrap at MaxLineLength, but prefer breaking at \n, space, or other boundaries
        var remaining = escaped;

        while (remaining.Length > 0)
        {
            var lineLength = MaxLineLength - 2; // Account for quotes

            if (remaining.Length <= lineLength)
            {
                sb.AppendLine($"\"{remaining}\"");
                break;
            }

            // Find a good break point
            var breakPoint = FindBreakPoint(remaining, lineLength);
            var line = remaining.Substring(0, breakPoint);
            remaining = remaining.Substring(breakPoint);

            sb.AppendLine($"\"{line}\"");
        }
    }

    private int FindBreakPoint(string text, int maxLength)
    {
        if (text.Length <= maxLength)
            return text.Length;

        // Prefer breaking after \n
        var newlinePos = text.LastIndexOf("\\n", maxLength, StringComparison.Ordinal);
        if (newlinePos > 0)
            return newlinePos + 2; // Include the \n

        // Prefer breaking at space
        for (int i = maxLength; i > maxLength / 2; i--)
        {
            if (text[i] == ' ')
                return i + 1;
        }

        // Just break at max length, but don't break escape sequences
        var breakAt = maxLength;
        if (breakAt > 0 && text[breakAt - 1] == '\\')
            breakAt--;

        return breakAt;
    }

    /// <summary>
    /// Escapes a string for PO format (handles \n, \t, \\, \").
    /// </summary>
    public static string EscapeString(string value)
    {
        if (string.IsNullOrEmpty(value))
            return value;

        var sb = new StringBuilder(value.Length * 2);
        foreach (var c in value)
        {
            switch (c)
            {
                case '\n':
                    sb.Append("\\n");
                    break;
                case '\t':
                    sb.Append("\\t");
                    break;
                case '\r':
                    sb.Append("\\r");
                    break;
                case '\\':
                    sb.Append("\\\\");
                    break;
                case '"':
                    sb.Append("\\\"");
                    break;
                default:
                    sb.Append(c);
                    break;
            }
        }

        return sb.ToString();
    }

    private string GetPluralFormsHeader(string languageCode)
    {
        var nplurals = PoPluralMapper.GetPluralCount(languageCode);

        // Return standard plural form expressions
        return languageCode.ToLowerInvariant() switch
        {
            // No plural
            "ja" or "ko" or "zh" or "vi" or "th" or "id" or "ms" or "tr"
                => "nplurals=1; plural=0;",

            // One, other (most common)
            "en" or "de" or "es" or "it" or "pt" or "nl" or "sv" or "da" or "no" or "fi" or "el" or "hu"
                => "nplurals=2; plural=(n != 1);",

            // French: 0 and 1 are singular
            "fr" => "nplurals=2; plural=(n > 1);",

            // Slavic 3-form (one, few, many)
            "ru" or "uk" or "be"
                => "nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);",

            // Polish
            "pl" => "nplurals=3; plural=(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);",

            // Czech/Slovak
            "cs" or "sk" => "nplurals=3; plural=(n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2;",

            // Latvian (zero, one, other)
            "lv" => "nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n != 0 ? 1 : 2);",

            // Lithuanian
            "lt" => "nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && (n%100<10 || n%100>=20) ? 1 : 2);",

            // Romanian
            "ro" => "nplurals=3; plural=(n==1 ? 0 : (n==0 || (n%100>0 && n%100<20)) ? 1 : 2);",

            // Arabic (6 forms)
            "ar" => "nplurals=6; plural=(n==0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 && n%100<=10 ? 3 : n%100>=11 ? 4 : 5);",

            // Slovenian (4 forms)
            "sl" => "nplurals=4; plural=(n%100==1 ? 0 : n%100==2 ? 1 : n%100==3 || n%100==4 ? 2 : 3);",

            // Default: treat like English
            _ => $"nplurals={nplurals}; plural={(nplurals == 1 ? "0" : "(n != 1)")};"
        };
    }

    private string GetFilePathForLanguage(string baseName, string cultureCode, string targetPath)
    {
        // Use configured folder structure
        return _config.FolderStructure.ToLowerInvariant() switch
        {
            "gnu" => Path.Combine(targetPath, "locale", cultureCode, "LC_MESSAGES", $"{baseName}.po"),
            "flat" or _ => Path.Combine(targetPath, $"{cultureCode}.po")
        };
    }

    private string GetLanguageDisplayName(string cultureCode)
    {
        try
        {
            var culture = CultureInfo.GetCultureInfo(cultureCode);
            return $"{culture.DisplayName} ({cultureCode})";
        }
        catch
        {
            return cultureCode;
        }
    }
}
